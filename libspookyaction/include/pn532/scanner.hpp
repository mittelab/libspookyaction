//
// Created by spak on 1/18/23.
//

#ifndef PN532_SCANNER_HPP
#define PN532_SCANNER_HPP

#include <pn532/controller.hpp>

namespace pn532 {
    class scanner;

    /**
     * @brief Action to perform after the @ref pn532::scanner has interacted with the target.
     */
    enum struct post_interaction {
        reject, ///@< Releases the target and prevents re-reading until out of the RF field
        release,///@< Releases the target, but will re-activate if not removed
        retain, ///@< Does not deactivate the target
        abort   ///@< Aborts the scan
    };

    /**
     * @brief Lightweight wrapper for a generic target detected by @ref controller.
     */
    struct scanned_target {
        /**
         * @brief Logical index to use e.g. in @ref controller::initiator_data_exchange.
         * @note This is irrelevant w.r.t. sorting and comparing.
         */
        std::uint8_t index = std::numeric_limits<std::uint8_t>::max();

        /**
         * @brief Type of detected tareget.
         */
        target_type type = target_type::generic_passive_106kbps;

        /**
         * @brief Some sort of unique NFC identifier.
         * @note This is not always available for all types of targets. When possible, a NFCID3t will be used.
         *  Otherwise it falls back to NFCID2t, NFCID1t, Jewel ID (for jewel tags), PUPI (Pseudo-Unique PICC
         *  Identifier, part of the ATQB response) and eventually, the ATQB response itself.
         */
        std::vector<std::uint8_t> nfcid{};

        /**
         * Default-constructs an invalid scanned target.
         */
        scanned_target() = default;

        /**
         * Constructs a scanned target from the
         * @tparam Type Any @ref target_type
         * @param index_ Logical index of the target. This is only needed for @ref poll_target_with_atr, otherwise
         *  the logical index passed inside @p entry will be used over the passed parameter.
         * @param entry Poll target entry, generated by @ref controller::initiator_auto_poll
         */
        template <target_type Type>
        scanned_target(std::uint8_t index_, poll_target<Type> const &entry);

        /**
         * Constructs a scanned target from the
         * @param index_ Logical index of the target. This is only needed for @ref poll_target_with_atr, otherwise
         *  the logical index passed inside @p entry will be used over the passed parameter.
         * @param entry Poll target entry, generated by @ref controller::initiator_auto_poll
         */
        scanned_target(std::uint8_t index_, any_poll_target const &entry);

        /**
         * @name Sorting and comparison
         * @{
         */
        [[nodiscard]] bool operator==(scanned_target const &other) const;
        [[nodiscard]] bool operator!=(scanned_target const &other) const;
        [[nodiscard]] bool operator<(scanned_target const &other) const;
        [[nodiscard]] bool operator>(scanned_target const &other) const;
        [[nodiscard]] bool operator<=(scanned_target const &other) const;
        [[nodiscard]] bool operator>=(scanned_target const &other) const;
        /**
         * @}
         */
    };

    /**
     * @brief Abstract class that reacts and controls a @ref scanner routine.
     */
    struct scanner_responder {
        /**
         * @brief Called before interaction with @p target begins.
         * The target has been activated and was not rejected.
         * @param scanner Scanner object
         * @param target Scanned target
         * @note Rejected targets will not trigger this call.
         */
        virtual void on_activation(scanner &scanner, scanned_target const &target) {}

        /**
         * @brief Called immediately before the release of @p target.
         * The target has been interacted with, and now it about to be released.
         * @param scanner Scanner object
         * @param target Scanned target
         * @note Targets that have been not interacted with (e.g. because rejected) will not trigger this call.
         */
        virtual void on_release(scanner &scanner, scanned_target const &target) {}

        /**
         * @brief Called when @p target has provably left the RF field.
         * This happens e.g. because it was not present in another scan, or the scan timed out.
         * @param scanner Scanner object
         * @param target Scanned target
         * @note Stopping with @ref scanner::stop the loop might cause this call to be skipped.
         */
        virtual void on_leaving_rf(scanner &scanner, scanned_target const &target) {}

        /**
         * @brief Called when @ref controller::initiator_auto_poll fails, e.g. due to timeout.
         * This is a normal condition as a scan with no tags will time out.
         * @param scanner Scanner object
         * @param err Error returned by the polling routine
         */
        virtual void on_failed_scan(scanner &scanner, channel_error err) {}

        /**
         * @brief Selects which targets the scanner should check.
         * The default implementation returns @ref controller::poll_all_targets.
         * @param scanner Scanner object.
         * @returns A non-empty list of scanning targets.
         * @warning The implementor should return least one target type, otherwise the loop will exit.
         */
        [[nodiscard]] virtual std::vector<target_type> get_scan_target_types(scanner &scanner) const {
            return controller::poll_all_targets;
        }

        /**
         * @brief Filter deciding whether a given target should be interacted with or not.
         * All rejected targets are automatically marked as "should not interact" until when they leave the RF
         * field. This is used e.g. to mark blocklisted tokens. The default implementation returns true.
         * Returning false prevents any of the calls to @ref on_activation, @ref interact and @ref on_release from occurring.
         * @param scanner Scanner object
         * @param target Tentative target to test before the interaction start
         * @return True for allowing interaction, false otherwise.
         */
        [[nodiscard]] virtual bool should_interact(scanner &scanner, scanned_target const &target) const {
            return true;
        }

        /**
         * @brief Core routine that interacts with the target.
         * The default implementation, rejects further interaction with this target until it leaves the RF field.
         * @param scanner Scanner object
         * @param target Scanned target
         * @returns One @ref post_interaction return codes.
         */
        [[nodiscard]] virtual post_interaction interact(scanner &scanner, scanned_target const &target) {
            return post_interaction::reject;
        }

        virtual ~scanner_responder() = default;
    };

    /**
     * @brief Helper class that continuously scans for targets and calls @ref scanner_responder methods in response.
     * This class can automatically track rejected targets and ignore them until they have left the RF field.
     * This is a move-only object.
     * @see controller::initiator_auto_poll
     *
     * @code
     * auto pn532 = pn532::controller(comm_channel);
     * if (not comm_channel.wake()) {
     *     std::printf("Channel did not wake!\n");
     * } else {
     *     pn532::scanner scanner{pn532};
     *     my_responder_subclass responder{};
     *     scanner.loop(responder);
     * }
     * @endcode
     */
    class scanner {
        controller *_ctrl = nullptr;
        ms _timeout = 5s;
        bool _stop = false;
        std::vector<scanned_target> _rejection_list{};
        std::vector<scanned_target> _in_rf{};

        /**
         * Remove all targets that are not in RF from the rejection list.
         * Trigger @ref scanner_responder::on_leaving_rf on targets that are not found anymore.
         */
        void update_rejection_list(scanner_responder &responder);

        /**
         * Rebuilds the @ref in_rf list starting from the current targets.
         */
        void update_in_rf_list(std::vector<any_poll_target> const &targets);

        /**
         * Tests whether a given target is in the rejection list.
         */
        [[nodiscard]] bool is_in_rejection_list(scanned_target const &target) const;

    public:
        /**
         * Default-constructs a scanner which does nothing. All methods exist immediately.
         */
        scanner() = default;

        /**
         * Constructs a scanner wrapping around @p ctrl.
         * @param ctrl The reference must stay valid throughout the whole lifetime of this object.
         * @param max_scan_interval Maximum interval after which a scan operation is aborted and restarted.
         */
        explicit scanner(controller &ctrl, ms max_scan_interval = 5s);

        scanner(scanner const &) = delete;
        scanner &operator=(scanner const &) = delete;
        scanner(scanner &&) noexcept = default;
        scanner &operator=(scanner &&) noexcept = default;

        /**
         * @brief List of targets currently in the RF field.
         */
        [[nodiscard]] inline std::vector<scanned_target> const &in_rf() const;

        /**
         * @brief Maximum interval of time after which @ref loop is guaranteed to check any @ref stop condition.
         * This corresponds to the timeout time of @ref controller::initiator_auto_poll.
         */
        [[nodiscard]] inline ms max_scan_interval() const;

        /**
         * @brief Changes @ref max_scan_interval.
         * @param timeout Maximum interval after which a scan operation is aborted and restarted.
         */
        inline void set_max_scan_interval(ms timeout);

        /**
         * @brief Main loop scanning for tags.
         * @param responder Responder class that reacts to the events.
         * @param init_and_test If True, @ref init_and_test_controller will be called before the loop starts, and exit if it fails.
         *  Otherwise, no test is performed and the loop jumps into scanning.
         */
        void loop(scanner_responder &responder, bool init_and_test = true);

        /**
         * @brief Reference to the controller.
         * @warning Calling this with a default-constructed @ref scanner will abort.
         */
        [[nodiscard]] controller &ctrl();

        /**
         * @copydoc ctrl
         */
        [[nodiscard]] controller const &ctrl() const;

        /**
         * @brief Aborts @ref loop.
         * This will only take effect at the next scan attempt, thus it will take @ref max_scan_interval ms
         * before @ref loop actually exits. This function returns immediately.
         */
        void stop();
    };
}// namespace pn532


namespace pn532 {

    ms scanner::max_scan_interval() const {
        return _timeout;
    }

    void scanner::set_max_scan_interval(ms timeout) {
        _timeout = timeout;
    }

    std::vector<scanned_target> const &scanner::in_rf() const {
        return _in_rf;
    }

    template <target_type Type>
    scanned_target::scanned_target(std::uint8_t index_, poll_target<Type> const &entry) : index{index_}, type{Type} {
        static constexpr auto BM = baudrate_modulation_of(Type);
        if constexpr (std::is_base_of_v<poll_target_dep_passive<BM>, poll_target<Type>>) {
            // Obtain NFCID3t from the atr_res_info, and the index from the target bit
            index = entry.logical_index;
            nfcid.resize(entry.atr_info.nfcid.size());
            std::copy(std::begin(entry.atr_info.nfcid), std::end(entry.atr_info.nfcid), std::begin(nfcid));
        } else if constexpr (std::is_base_of_v<target<BM>, poll_target<Type>>) {
            // Obtain the logical index from the target bit, and then differentiate
            index = entry.logical_index;
            if constexpr (BM == baudrate_modulation::kbps106_iso_iec_14443_typea) {
                nfcid = entry.nfcid;
            } else if constexpr (BM == baudrate_modulation::kbps212_felica or BM == baudrate_modulation::kbps424_felica) {
                nfcid.resize(entry.nfcid_2t.size());
                std::copy(std::begin(entry.nfcid_2t), std::end(entry.nfcid_2t), std::begin(nfcid));
            } else if constexpr (BM == baudrate_modulation::kbps106_iso_iec_14443_3_typeb) {
                // Slice off the PUPI (Pseudo-Unique PICC Identifier) out of the atqb response
                if (entry.atqb_response.size() >= 5) {
                    nfcid.resize(4);
                    std::copy_n(std::begin(entry.atqb_response) + 1, 4, std::begin(nfcid));
                } else {
                    // Just use the whole atqb response
                    nfcid.resize(entry.atqb_response.size());
                    std::copy(std::begin(entry.atqb_response), std::end(entry.atqb_response), std::begin(nfcid));
                }
            } else if constexpr (BM == baudrate_modulation::kbps106_innovision_jewel_tag) {
                // Use jewel id
                nfcid.resize(entry.jewel_id.size());
                std::copy(std::begin(entry.jewel_id), std::end(entry.jewel_id), std::begin(nfcid));
            }
        } else {
            static_assert(std::is_base_of_v<poll_target_with_atr, poll_target<Type>>);
            // Obtain NFCID3t from the atr_res_info, we cannot do anything about the index
            nfcid.resize(entry.atr_info.nfcid.size());
            std::copy(std::begin(entry.atr_info.nfcid), std::end(entry.atr_info.nfcid), std::begin(nfcid));
        }
    }
}// namespace pn532
#endif//PN532_SCANNER_HPP
